package method;import java.util.ArrayList;import java.util.Deque;import java.util.LinkedList;import java.util.List;/** * <p> * 145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 * </p> * * @author lipeilong * @time 2020/9/29 19:16 * @description 145. 二叉树的后序遍历 给定一个二叉树，返回它的 后序 遍历。 */public class 二叉树的后序遍历 {    /**     * 迭代算法     *     * @param root:     * @return java.util.List<java.lang.Integer>     * @author lipeilong     * @time 2020/9/29 19:41     * @description 迭代算法     */    public List<Integer> postorderTraversal(TreeNode root) {        LinkedList<Integer> result = new LinkedList<>();        Deque<TreeNode> stack = new LinkedList<>();        while (root != null || !stack.isEmpty()) {            if (root != null) {                stack.addFirst(root);                result.addFirst(root.val);                root = root.right;            } else {                root = stack.remove();                root = root.left;            }        }        return result;    }    /**     * 递归算法     *     * @param root:     * @return java.util.List<java.lang.Integer>     * @author lipeilong     * @time 2020/9/29 19:40     * @description 递归算法     */    List<Integer> res = new ArrayList<>();    public List<Integer> postorderTraversal1(TreeNode root) {        if (root == null) {            return res;        }        postorderTraversal1(root.left);        postorderTraversal1(root.right);        res.add(root.val);        return res;    }    public class TreeNode {        int val;        TreeNode left;        TreeNode right;        TreeNode() {        }        TreeNode(int val) {            this.val = val;        }        TreeNode(int val, TreeNode left, TreeNode right) {            this.val = val;            this.left = left;            this.right = right;        }    }}