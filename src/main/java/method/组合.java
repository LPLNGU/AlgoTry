package method;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;import java.util.List;/** * <p> * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。  示例:  输入: n = 4, k = 2 输出: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]  来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combinations * </p> * * @author lipeilong * @time 2020/9/8 14:10 * @description 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。  示例:  输入: n = 4, k = 2 输出: [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]  来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/combinations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class 组合 {    public List<List<Integer>> combine(int n, int k) {        List<List<Integer>> res = new ArrayList<>();        Deque<Integer> path = new ArrayDeque<>();        dfs(n, k, 1, path, res);        return res;    }    private void dfs(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {        if (path.size() == k) {            res.add(new ArrayList<>(path));            return;        }        for (int i = begin; i <= n - (k - path.size()) + 1; i++) {            path.addLast(i);            // 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素            dfs(n, k, i + 1, path, res);            // 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作            path.removeLast();        }    }}