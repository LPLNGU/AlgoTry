package method;/** * <p> * 110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。  本题中，一棵高度平衡二叉树定义为：  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 * </p> * * @author lipeilong * @time 2020/9/16 17:52 * @description 110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。  本题中，一棵高度平衡二叉树定义为：  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 */public class 平衡二叉树 {    /**     * 解法2：自底向上     *     * @param root:     * @return boolean     * @author lipeilong     * @time 2020/9/16 18:16     * @description 解法2：自底向上     */    Boolean res = true;    public boolean isBalanced(TreeNode root) {        height(root);        return res;    }    private int height(TreeNode node) {        if (node == null) {            return 0;        }        int leftHeight = height(node.left) + 1;        int rightHeight = height(node.right) + 1;        if (Math.abs(leftHeight - rightHeight) > 1) {            res = false;        }        return Math.max(leftHeight, rightHeight);    }    //    /**//     * 解法1：自顶向下//     *//     * @author lipeilong//     * @time 2020/9/16 18:17//     * @param root://     * @return boolean//     * @description 解法1：自顶向下//     *///    public boolean isBalanced(TreeNode root) {//////        if (root == null) {//            return true;//        }//        return (Math.abs(height(root.left) - height(root.right)) <= 1) && isBalanced(root.left) && isBalanced(root.right);//    }////    private int height(TreeNode node) {//        if (node == null) {//            return 0;//        }//        return Math.max(height(node.left), height(node.right)) + 1;//    }    public class TreeNode {        int val;        TreeNode left;        TreeNode right;        TreeNode(int x) {            val = x;        }    }}