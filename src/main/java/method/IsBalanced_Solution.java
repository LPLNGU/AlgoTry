package method;/** * 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 * <p> * 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 */public class IsBalanced_Solution {    //    /**//     * 这种算法需要遍历所有节点，效率不高//     * @param root//     * @return//     *///    public boolean IsBalanced_Solution(TreeNode root) {//        if (root == null) {//            return true;//        }////        return Math.abs(countSon(root.left) - countSon(root.right)) <= 1 &&//                IsBalanced_Solution(root.left) &&//                IsBalanced_Solution(root.right);//    }////    public int countSon(TreeNode root) {//        if (root == null) {//            return 0;//        }//        return 1 + Math.max(countSon(root.left), countSon(root.right));//    }    public boolean IsBalanced_Solution(TreeNode root) {        return isBalanced(root) != -1;    }    /**     * 不平衡返回-1，平衡的时候返回深度     *     * @param root     * @return     */    private int isBalanced(TreeNode root) {        if (root == null) {            return 0;        }        int left = isBalanced(root.left);        if (left == -1) {            return -1;        }        int right = isBalanced(root.right);        if (right == -1) {            return -1;        }        return Math.abs(left - right) <= 1 ? 1 + Math.max(left, right) : -1;    }    public class TreeNode {        int val = 0;        TreeNode left = null;        TreeNode right = null;        public TreeNode(int val) {            this.val = val;        }    }}