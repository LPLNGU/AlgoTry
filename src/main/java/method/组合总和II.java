package method;import java.util.*;/** * <p> * 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。  candidates 中的每个数字在每个组合中只能使用一次。  说明：  所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。  示例 1:  输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ] 示例 2:  输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [   [1,2,2],   [5] ] * </p> * * @author lipeilong * @time 2020/9/10 13:31 * @description 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。  candidates 中的每个数字在每个组合中只能使用一次。  说明：  所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。  示例 1:  输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [   [1, 7],   [1, 2, 5],   [2, 6],   [1, 1, 6] ] 示例 2:  输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [   [1,2,2],   [5] ] */public class 组合总和II {    public List<List<Integer>> combinationSum2(int[] candidates, int target) {        if (candidates.length <= 0) {            return new ArrayList<>();        }        //关键步骤        Arrays.sort(candidates);        Deque<Integer> path = new ArrayDeque<>();        List<List<Integer>> res = new ArrayList<>();        dfs(candidates, target, path, 0, res);        return res;    }    public void dfs(int[] candidates, int target, Deque<Integer> path, int index, List<List<Integer>> result) {        if (target == 0) {            result.add(new ArrayList<>(path));            return;        }        for (int i = index; i < candidates.length; i++) {            //大剪枝,由于数据顺序排列，后面的都更大，因此无需遍历            if (target - candidates[i] < 0) {                break;            }            //小剪枝函数,这里注意使用continue，不要剪枝多了，导致缺值            if (i > index && candidates[i] == candidates[i - 1]) {                continue;            }            path.add(candidates[i]);            dfs(candidates, target - candidates[i], path, i + 1, result);            path.remove(candidates[i]);        }    }}